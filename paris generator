#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Morse ".paris" generator with extended parameters (tone, weight, jitter, etc.)
and a simple Tkinter GUI (minimal dependencies).

- Enter text
- Choose character & Farnsworth WPM
- Configure timing/weight/tone/jitter
- Export a .paris file (CSV renamed)

Format:
# Word: <your text>
# Character speed: <char_wpm> WPM
# Farnsworth spacing: <farns_wpm> WPM effective timing
# Tone frequency: <freq> Hz
# Weight ratio: <dot_to_dash_ratio>
# Rise/Fall time: <ms>
# Envelope: <shape>
# Jitter: <±%>
# Pre-key delay: <ms>
# Post-key delay: <ms>
# Encoding: International Morse
duration_ms,value
<ms>,<1|0>

Author: ChatGPT
License: MIT
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import math, random

# Morse map (International)
MORSE = {
    "A": ".-", "B": "-...", "C": "-.-.", "D": "-..", "E": ".",
    "F": "..-.", "G": "--.", "H": "....", "I": "..", "J": ".---",
    "K": "-.-", "L": ".-..", "M": "--", "N": "-.", "O": "---",
    "P": ".--.", "Q": "--.-", "R": ".-.", "S": "...", "T": "-",
    "U": "..-", "V": "...-", "W": ".--", "X": "-..-", "Y": "-.--",
    "Z": "--..",
    "0": "-----", "1": ".----", "2": "..---", "3": "...--", "4": "....-",
    "5": ".....", "6": "-....", "7": "--...", "8": "---..", "9": "----.",
    ".": ".-.-.-", ",": "--..--", "?": "..--..", "'": ".----.", "!": "-.-.--",
    "/": "-..-.", "(": "-.--.", ")": "-.--.-", "&": ".-...", ":": "---...",
    ";": "-.-.-.", "=": "-...-", "+": ".-.-.", "-": "-....-", "_": "..--.-",
    '"': ".-..-.", "$": "...-..-", "@": ".--.-."
}

def dot_ms(wpm: float) -> float:
    """Duration of a dot in milliseconds for given WPM."""
    return 1200.0 / max(wpm, 1e-9)

def apply_jitter(duration, jitter_pct):
    """Apply random ±% jitter to a duration."""
    if jitter_pct <= 0:
        return duration
    factor = 1.0 + random.uniform(-jitter_pct/100.0, jitter_pct/100.0)
    return duration * factor

def build_paris_rows(text: str, char_wpm: float, farns_wpm: float,
                     weight: float, jitter: float,
                     pre_delay: int, post_delay: int):
    """Build rows of (duration_ms, value) including jitter and weighting."""
    eff_wpm = min(farns_wpm, char_wpm) if farns_wpm > 0 else char_wpm
    d_dot_char = dot_ms(char_wpm)
    d_dot_eff = dot_ms(eff_wpm)

    d_dash = weight * d_dot_char
    d_intra = d_dot_char
    d_inter_char = 3 * d_dot_eff
    d_inter_word = 7 * d_dot_eff

    rows = []
    if pre_delay > 0:
        rows.append((int(pre_delay), 0))

    words = text.strip().split()
    for wi, w in enumerate(words):
        for ci, ch in enumerate(w):
            code = MORSE.get(ch.upper())
            if not code:
                continue
            for ei, elem in enumerate(code):
                dur = d_dot_char if elem == "." else d_dash
                dur = apply_jitter(dur, jitter)
                rows.append((int(round(dur)), 1))
                if ei < len(code) - 1:
                    rows.append((int(round(apply_jitter(d_intra, jitter))), 0))
            if ci < len(w) - 1:
                rows.append((int(round(apply_jitter(d_inter_char, jitter))), 0))
        if wi < len(words) - 1:
            rows.append((int(round(apply_jitter(d_inter_word, jitter))), 0))

    if post_delay > 0:
        rows.append((int(post_delay), 0))
    return rows

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Morse .paris Generator (Extended)")
        self.geometry("780x640")
        self.minsize(740, 560)

        frm = ttk.Frame(self, padding=12)
        frm.pack(fill="both", expand=True)

        ttk.Label(frm, text="Text to encode:").grid(row=0, column=0, sticky="w")
        self.txt_input = tk.Text(frm, height=5, wrap="word")
        self.txt_input.grid(row=1, column=0, columnspan=6, sticky="nsew", pady=(4,10))
        self.txt_input.insert("1.0", "PARIS")

        # Speed controls
        ttk.Label(frm, text="Character WPM:").grid(row=2, column=0, sticky="w")
        self.var_char_wpm = tk.StringVar(value="15")
        ttk.Entry(frm, textvariable=self.var_char_wpm, width=10).grid(row=2, column=1, sticky="w")

        ttk.Label(frm, text="Farnsworth WPM:").grid(row=2, column=2, sticky="w")
        self.var_farns_wpm = tk.StringVar(value="5")
        ttk.Entry(frm, textvariable=self.var_farns_wpm, width=10).grid(row=2, column=3, sticky="w")

        # Extended timing parameters
        ttk.Label(frm, text="Weight (dot:dash ratio):").grid(row=3, column=0, sticky="w")
        self.var_weight = tk.StringVar(value="3.0")
        ttk.Entry(frm, textvariable=self.var_weight, width=10).grid(row=3, column=1, sticky="w")

        ttk.Label(frm, text="Tone (Hz):").grid(row=3, column=2, sticky="w")
        self.var_tone = tk.StringVar(value="600")
        ttk.Entry(frm, textvariable=self.var_tone, width=10).grid(row=3, column=3, sticky="w")

        ttk.Label(frm, text="Rise/Fall (ms):").grid(row=3, column=4, sticky="w")
        self.var_risefall = tk.StringVar(value="8")
        ttk.Entry(frm, textvariable=self.var_risefall, width=10).grid(row=3, column=5, sticky="w")

        ttk.Label(frm, text="Jitter (±%):").grid(row=4, column=0, sticky="w")
        self.var_jitter = tk.StringVar(value="0")
        ttk.Entry(frm, textvariable=self.var_jitter, width=10).grid(row=4, column=1, sticky="w")

        ttk.Label(frm, text="Pre-delay (ms):").grid(row=4, column=2, sticky="w")
        self.var_pre = tk.StringVar(value="0")
        ttk.Entry(frm, textvariable=self.var_pre, width=10).grid(row=4, column=3, sticky="w")

        ttk.Label(frm, text="Post-delay (ms):").grid(row=4, column=4, sticky="w")
        self.var_post = tk.StringVar(value="0")
        ttk.Entry(frm, textvariable=self.var_post, width=10).grid(row=4, column=5, sticky="w")

        # Buttons
        btns = ttk.Frame(frm)
        btns.grid(row=5, column=0, columnspan=6, sticky="w", pady=(10,6))
        ttk.Button(btns, text="Preview", command=self.on_preview).pack(side="left", padx=(0,8))
        ttk.Button(btns, text="Export .paris", command=self.on_export).pack(side="left")

        # Preview area
        ttk.Label(frm, text="Preview:").grid(row=6, column=0, columnspan=6, sticky="w")
        self.txt_preview = tk.Text(frm, height=14, wrap="none")
        self.txt_preview.grid(row=7, column=0, columnspan=6, sticky="nsew", pady=(4,0))

        # Layout weights
        for i in (1,7):
            frm.rowconfigure(i, weight=1)
        frm.columnconfigure(0, weight=1)

    def parse_floats(self, *vars_):
        vals = []
        for v in vars_:
            try:
                vals.append(float(v.get()))
            except:
                messagebox.showerror("Invalid input", "Please enter numeric values only.")
                return None
        return vals

    def generate_text(self):
        vals = self.parse_floats(self.var_char_wpm, self.var_farns_wpm,
                                 self.var_weight, self.var_tone,
                                 self.var_risefall, self.var_jitter,
                                 self.var_pre, self.var_post)
        if vals is None:
            return None
        char_wpm, farns_wpm, weight, tone, risefall, jitter, pre, post = vals
        raw = self.txt_input.get("1.0", "end").strip()
        if not raw:
            messagebox.showwarning("No text", "Enter text to encode.")
            return None

        rows = build_paris_rows(raw, char_wpm, farns_wpm, weight, jitter, pre, post)
        header = [
            f"# Word: {raw}",
            f"# Character speed: {char_wpm:.2f} WPM",
            f"# Farnsworth spacing: {farns_wpm:.2f} WPM effective timing",
            f"# Tone frequency: {tone:.1f} Hz",
            f"# Weight ratio: 1:{weight:.2f}",
            f"# Rise/Fall time: {risefall:.1f} ms",
            f"# Envelope: cosine",
            f"# Jitter: ±{jitter:.1f}%",
            f"# Pre-key delay: {pre:.1f} ms",
            f"# Post-key delay: {post:.1f} ms",
            f"# Encoding: International Morse",
            "duration_ms,value"
        ]
        lines = header + [f"{d},{v}" for (d, v) in rows]
        return "\n".join(lines)

    def on_preview(self):
        content = self.generate_text()
        if content is None:
            return
        self.txt_preview.delete("1.0", "end")
        lines = content.splitlines()
        if len(lines) > 200:
            self.txt_preview.insert("1.0", "\n".join(lines[:200]) + f"\n# ... ({len(lines)-200} more lines)")
        else:
            self.txt_preview.insert("1.0", content)

    def on_export(self):
        content = self.generate_text()
        if content is None:
            return
        default_name = "output.paris"
        raw = self.txt_input.get("1.0", "end").strip()
        if raw:
            base = "_".join(raw.split())
            if base:
                default_name = f"{base}.paris"
        path = filedialog.asksaveasfilename(
            title="Save .paris file", defaultextension=".paris",
            initialfile=default_name, filetypes=[("PARIS files", "*.paris"), ("All files", "*.*")]
        )
        if not path:
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(content)
            messagebox.showinfo("Saved", f"File saved:\n{path}")
        except Exception as e:
            messagebox.showerror("Save failed", str(e))

def main():
    App().mainloop()

if __name__ == "__main__":
    main()
